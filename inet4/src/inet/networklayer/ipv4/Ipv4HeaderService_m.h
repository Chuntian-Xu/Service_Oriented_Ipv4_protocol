//
// Generated file, do not edit! Created by nedtool 5.6 from inet/networklayer/ipv4/Ipv4HeaderService.msg.
//

#ifndef __INET_IPV4HEADERSERVICE_M_H
#define __INET_IPV4HEADERSERVICE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class Ipv4HeaderService;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/TlvOptions_m.h" // import inet.common.TlvOptions

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/common/IpProtocolId_m.h" // import inet.networklayer.common.IpProtocolId

#include "inet/networklayer/contract/NetworkHeaderBase_m.h" // import inet.networklayer.contract.NetworkHeaderBase

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/transportlayer/common/CrcMode_m.h" // import inet.transportlayer.common.CrcMode

#include "inet/networklayer/contract/serviceid/ServiceId_m.h" // import inet.networklayer.contract.serviceid.ServiceId

// cplusplus {{
#include "inet/common/ProtocolGroup.h"
// }}


namespace inet {

// cplusplus {{
// default IPv4ServiceID header length: 4 bytes
const B IPv4ServiceID_MIN_HEADER_LENGTH = B(4);

// maximum IPv4ServiceID header length (base+options): 6+4 = 10 bytes
const B IPv4ServiceID_MAX_HEADER_LENGTH = B(10);
// }}

/**
 * Class generated from <tt>inet/networklayer/ipv4/Ipv4HeaderService.msg:35</tt> by nedtool.
 * <pre>
 * // Represents an IPv4ServiceID datagram.
 * //
 * // Uses the following cPacket fields:
 * //    - getByteLength() / setByteLength() to represent total datagram length
 * // Additional length fields defined in this class are in bytes.
 * //
 * class Ipv4HeaderService extends NetworkHeaderBase
 * {
 *     chunkLength = IPv4ServiceID_MIN_HEADER_LENGTH;
 *     B headerLength = IPv4ServiceID_MIN_HEADER_LENGTH;
 *     ServiceId srcServiceId;
 *     ServiceId destServiceId;
 * }
 * </pre>
 */
class INET_API Ipv4HeaderService : public ::inet::NetworkHeaderBase
{
  protected:
    B headerLength = IPv4ServiceID_MIN_HEADER_LENGTH;
    ServiceId srcServiceId;
    ServiceId destServiceId;

  private:
    void copy(const Ipv4HeaderService& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv4HeaderService&);

  public:
    Ipv4HeaderService();
    Ipv4HeaderService(const Ipv4HeaderService& other);
    virtual ~Ipv4HeaderService();
    Ipv4HeaderService& operator=(const Ipv4HeaderService& other);
    virtual Ipv4HeaderService *dup() const override {return new Ipv4HeaderService(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual B getHeaderLength() const;
    virtual void setHeaderLength(B headerLength);
    virtual const ServiceId& getSrcServiceId() const;
    virtual ServiceId& getSrcServiceIdForUpdate() { handleChange();return const_cast<ServiceId&>(const_cast<Ipv4HeaderService*>(this)->getSrcServiceId());}
    virtual void setSrcServiceId(const ServiceId& srcServiceId);
    virtual const ServiceId& getDestServiceId() const;
    virtual ServiceId& getDestServiceIdForUpdate() { handleChange();return const_cast<ServiceId&>(const_cast<Ipv4HeaderService*>(this)->getDestServiceId());}
    virtual void setDestServiceId(const ServiceId& destServiceId);

  public:
    // implements NetworkHeaderBase:
    virtual L3Address getSourceAddress() const override { return L3Address(getSrcServiceId()); }
    virtual void setSourceAddress(const L3Address& address) override { setSrcServiceId(address.toServiceId()); }
    virtual L3Address getDestinationAddress() const override { return L3Address(getDestServiceId()); }
    virtual void setDestinationAddress(const L3Address& address) override { setDestServiceId(address.toServiceId()); }
    virtual const Protocol *getProtocol() const override {}
    virtual void setProtocol(const Protocol *protocol) override {}
    virtual bool isFragment() const override {}
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv4HeaderService& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv4HeaderService& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_IPV4HEADERSERVICE_M_H

